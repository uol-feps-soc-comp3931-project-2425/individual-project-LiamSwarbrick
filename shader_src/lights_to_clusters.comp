#version 460 core

// Different sizes yield similar performance results, Intel Iris likely prefers 512
#define LOCAL_SIZE 512//128
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

struct PointLight
{
    vec4 position_xyz_range_w;
    vec4 color_rgb_intensity_a;
};


#define MAX_UNCLIPPED_NGON 10
struct AreaLight
{
    vec4 color_rgb_intensity_a;
    int n;
    int is_double_sided;
    float _packing0, _packing1;
    vec4 aabb_min;
    vec4 aabb_max;
    vec4 sphere_of_influence_center_xyz_radius_w;
    vec4 points_viewspace[MAX_UNCLIPPED_NGON];  // 4th component unused, vec3[] would be packed the same way but vec3 is implemented wrong on some drivers
};

#ifndef CLUSTER_MAX_LIGHTS
    #define CLUSTER_MAX_LIGHTS 100
#endif
struct Cluster
{
    vec4 min_point;
    vec4 max_point;
    uint point_count;
    uint area_count;
    uint point_indices[CLUSTER_MAX_LIGHTS/2];
    uint area_indices[CLUSTER_MAX_LIGHTS/2];
};

layout (std430, binding = 0) restrict buffer point_light_ssbo
{
    PointLight point_lights[];
};

layout (std430, binding = 2) restrict buffer area_light_ssbo
{
    AreaLight area_lights[];
};

layout (std430, binding = 1) restrict buffer cluster_ssbo
{
    Cluster clusters[];
};

// layout (location = 0) uniform mat4 view_matrix;
layout (location = 1) uniform uint num_point_lights;
layout (location = 2) uniform uint num_area_lights;

bool
sphere_aabb_intersection(vec3 center, float radius, vec3 aabb_min, vec3 aabb_max)
{
    // Cloest point of AABB to the center of the sphere
    vec3 closest_point = clamp(center, aabb_min, aabb_max);
    closest_point -= center;
    float distance_squared = dot(closest_point, closest_point);
    return distance_squared <= radius * radius;
}

bool
test_sphere_aabb(uint i, Cluster cluster)
{
    // vec3 center = vec3(view_matrix * vec4(point_lights[i].position_xyz_range_w.xyz, 1.0));
    vec3 center = point_lights[i].position_xyz_range_w.xyz;  // <- lights are already in view space
    float radius = point_lights[i].position_xyz_range_w.w;
    return sphere_aabb_intersection(center, radius, cluster.min_point.xyz, cluster.max_point.xyz);
}

bool
aabb_aabb_intersect(vec3 aabb1_min, vec3 aabb1_max, 
                         vec3 aabb2_min, vec3 aabb2_max) 
{
    // Bloody epic mate
    bvec3 overlap = greaterThanEqual(aabb1_max, aabb2_min) &
                    lessThanEqual(aabb1_min, aabb2_max);
    return all(overlap);
}

bool
test_arealight(uint i, Cluster cluster)
{
    // Early reject if not inside AABB of light emission
    if (!aabb_aabb_intersect(area_lights[i].aabb_min.xyz, area_lights[i].aabb_max.xyz,
            cluster.min_point.xyz, cluster.max_point.xyz))
    {
        return false;
    }

    // Half space rejection for single sided area lights
    if (area_lights[i].is_double_sided == 0)
    {
        vec3 a = area_lights[i].points_viewspace[0].xyz;
        vec3 b = area_lights[i].points_viewspace[1].xyz;
        vec3 c = area_lights[i].points_viewspace[2].xyz;
        vec3 light_normal = cross(b - a, c - a);

        vec3 cluster_center = (cluster.min_point.xyz + cluster.max_point.xyz) * 0.5;
        vec3 cluster_half_dimensions = (cluster.max_point.xyz - cluster.min_point.xyz) * 0.5;
        float margin = 2.0 * dot(cluster_half_dimensions, abs(light_normal));
        // float margin = 0.0;
        
        vec3 polygon_centroid = area_lights[i].sphere_of_influence_center_xyz_radius_w.xyz;

        if (dot(cluster_center - polygon_centroid, light_normal) + margin < 0.0)
        // if (
        //     dot(cluster.min_point.xyz - polygon_centroid, light_normal) < 0.0 &&
        //     dot(cluster.max_point.xyz - polygon_centroid, light_normal) < 0.0 &&
        // )
        {
            return false;
        }
    }

    // More precise sphere test:
    vec4 sphere = area_lights[i].sphere_of_influence_center_xyz_radius_w;
    return sphere_aabb_intersection(sphere.xyz, sphere.w, cluster.min_point.xyz, cluster.max_point.xyz);
}

void
main()
{
    uint index = gl_GlobalInvocationID.x;
    Cluster cluster = clusters[index];

    // Reinitialize count to 0 before computing this frames cluster
    cluster.point_count = 0;
    cluster.area_count = 0;

    const uint max_point_lights = CLUSTER_MAX_LIGHTS/2;
    const uint max_area_lights = CLUSTER_MAX_LIGHTS/2;

    for (uint i = 0; i < num_point_lights; ++i)
    {
        if (test_sphere_aabb(i, cluster) && cluster.point_count < max_point_lights)
        {
            cluster.point_indices[cluster.point_count++] = i;
        }
    }

    for (uint i = 0; i < num_area_lights; ++i)
    {
        if (test_arealight(i, cluster) && cluster.area_count < max_area_lights)
        {
            cluster.area_indices[cluster.area_count++] = i;
        }
    }

    clusters[index] = cluster;
}
