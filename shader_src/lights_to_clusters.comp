#version 460 core

// Different sizes yield similar performance results, Intel Iris likely prefers 512
#define LOCAL_SIZE 512//128
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

struct PointLight
{
    vec4 position_xyz_range_w;
    vec4 color_rgb_intensity_a;
};


#define MAX_UNCLIPPED_NGON 10
struct AreaLight
{
    vec4 color_rgb_intensity_a;
    int n;
    int is_double_sided;
    float _packing0, _packing1;
    vec4 aabb_min;
    vec4 aabb_max;
    vec4 sphere_of_influence_center_xyz_radius_w;
    vec4 points_viewspace[MAX_UNCLIPPED_NGON];  // 4th component unused, vec3[] would be packed the same way but vec3 is implemented wrong on some drivers
};

#ifndef CLUSTER_MAX_LIGHTS
    #define CLUSTER_MAX_LIGHTS 100
#endif
struct Cluster
{
    vec4 min_point;
    vec4 max_point;
    uint point_count;
    uint area_count;
    uint point_indices[CLUSTER_MAX_LIGHTS/2];
    uint area_indices[CLUSTER_MAX_LIGHTS/2];
    uint area_light_flags[CLUSTER_MAX_LIGHTS/2];  // 0b00 = neither, 0b01 = diffuse, 0b10 = specular, 0b11 = both
};

layout (std430, binding = 0) restrict buffer point_light_ssbo
{
    PointLight point_lights[];
};

layout (std430, binding = 2) restrict buffer area_light_ssbo
{
    AreaLight area_lights[];
};

layout (std430, binding = 1) restrict buffer cluster_ssbo
{
    Cluster clusters[];
};

// layout (location = 0) uniform mat4 view_matrix;
layout (location = 1) uniform uint num_point_lights;
layout (location = 2) uniform uint num_area_lights;

layout (binding = 7) uniform usamplerCube cluster_normals_cubemap;
layout (binding = 8) uniform sampler1D representative_normals_texture;

#define M_PI 3.1415926535897932384626433832795

struct NormalCone
{
    float half_angle;
    float cos_threshold;
    float sin_threshold;
    vec3 cluster_normal;
};

bool
sphere_aabb_intersection(vec3 center, float radius, vec3 aabb_min, vec3 aabb_max)
{
    // Cloest point of AABB to the center of the sphere
    vec3 closest_point = clamp(center, aabb_min, aabb_max);
    closest_point -= center;
    float distance_squared = dot(closest_point, closest_point);
    return distance_squared <= radius * radius;
}

bool
test_sphere_aabb(uint i, Cluster cluster, NormalCone normal_cone)
{
    // Does light affect this cluster based on position
    vec3 light_pos = point_lights[i].position_xyz_range_w.xyz;  // <- lights are already in view space
    float radius = point_lights[i].position_xyz_range_w.w;
    if (!sphere_aabb_intersection(light_pos, radius, cluster.min_point.xyz, cluster.max_point.xyz))
    {
        return false;
    }

#if CLUSTER_NORMALS_COUNT != 1
// NOTE: Backface culling pointlights not working properly
    // // Does light affect this cluster based on normal (Backface culling of lights)
    // vec3 cluster_center = (cluster.min_point.xyz + cluster.max_point.xyz) * 0.5;
    // vec3 to_light = normalize(light_pos - cluster_center);
    // if (dot(normal_cone.cluster_normal, to_light) < -normal_cone.cos_threshold)
    // {
    //     return false;
    // }
#endif

    return true;
}

bool
aabb_aabb_intersect(vec3 aabb1_min, vec3 aabb1_max, 
                         vec3 aabb2_min, vec3 aabb2_max) 
{
    // Bloody epic mate
    // bvec3 overlap = greaterThanEqual(aabb1_max, aabb2_min) &
    //                lessThanEqual(aabb1_min, aabb2_max);
    // return all(overlap);

    return all(greaterThanEqual(aabb1_max, aabb2_min)) && all(lessThanEqual(aabb1_min, aabb2_max));
}

bool
is_aabb_fully_behind_plane(vec3 aabb_min, vec3 aabb_max, vec3 plane_normal, float plane_constant)
{
    // Plane defined by dot(N,X) + d = 0

    // Get the point in the further direction of the normal
    vec3 furthest_point = vec3(
        plane_normal.x >= 0.0 ? aabb_max.x : aabb_min.x,
        plane_normal.y >= 0.0 ? aabb_max.y : aabb_min.y,
        plane_normal.z >= 0.0 ? aabb_max.z : aabb_min.z
    );

    float signed_distance = dot(plane_normal, furthest_point) + plane_constant;

    // If the signed distance to point closest to the positive side of the plane is negative
    // Then the AABB is behind the plane
    return signed_distance < 0;
}

uint
test_arealight(uint i, Cluster cluster, NormalCone normal_cone)
{
    // Half space rejection for single sided area lights
    if (area_lights[i].is_double_sided == 0)
    {
        // Find plane equation for area light
        vec3 a = area_lights[i].points_viewspace[0].xyz;
        vec3 b = area_lights[i].points_viewspace[1].xyz;
        vec3 c = area_lights[i].points_viewspace[2].xyz;
        vec3 plane_normal = cross(b - a, c - a);
        float plane_constant = -dot(plane_normal, a);  // d = -dot(N,X)

        if (is_aabb_fully_behind_plane(cluster.min_point.xyz, cluster.max_point.xyz, plane_normal, plane_constant))
        {
            return 0u;
        }
    }

    // Area light diffuse bounding sphere precomputed on CPU each frame
    vec4 sphere = area_lights[i].sphere_of_influence_center_xyz_radius_w;

    // OLD backface culling: The sphere approximation would wasn't good enough causing artefacts
    // vec3 cluster_center = (cluster.min_point.xyz + cluster.max_point.xyz) * 0.5;
    // vec3 to_light = normalize(sphere.xyz - cluster_center);
    // if (dot(normal_cone.cluster_normal, to_light) < -normal_cone.cos_threshold)
    // {
    //     return false;
    // }

// SPECULAR:
    bool specular_passed = false;
    vec3 cluster_center = (cluster.min_point.xyz + cluster.max_point.xyz) * 0.5;
    vec3 view_dir = normalize(-cluster_center);

    float param_roughness             = 1.0;
    float param_min_intensity         = 0.01;
    float param_intensity_saturation  = 10.0;//= 0.5;//=100.0;
    // NOTE: Can set intensity saturation to like 50.0 or 100.0 in scenes mostly composed of rough materials
    // In scenes almost entirely shiny then setting to 1.0 or 0.5 may be necessary to avoid obvious cutting off of specular.

    vec3 light_sphere_center = area_lights[i].sphere_of_influence_center_xyz_radius_w.xyz;
    float light_sphere_radius = area_lights[i].sphere_of_influence_center_xyz_radius_w.w;
    float distance_to_light = distance(cluster_center, light_sphere_center);
    float effective_distance = max(distance_to_light - light_sphere_radius, 0.0);
    float attenuation = 1.0 / (1.0 + effective_distance * effective_distance);
    float scaled_intensity = (area_lights[i].color_rgb_intensity_a.a * attenuation) / 
                            (area_lights[i].color_rgb_intensity_a.a * attenuation + param_intensity_saturation);
    float specular_tau = pow(param_min_intensity / (scaled_intensity + 1e-6), 1.0 / param_roughness);


#if CLUSTER_NORMALS_COUNT == 1  // Normal based clustering disabled
    // // This code doesn't work
    // vec3 light_pos = sphere.xyz;
    // vec3 light_to_cluster_dir = normalize(cluster_center - light_pos);
    // vec3 view_dir = normalize(-cluster_center);  // cluster to camera direction

    // const float specular_threshold = 0.5;  // 0.0 for completely shiny materials in scene
    // specular_passed = dot(light_to_cluster_dir, view_dir) >= specular_threshold;

    // The only thing guarunteed to work is to assign specular to all clusters in the half space
    // specular_passed = true;

    vec3 light_center = area_lights[i].sphere_of_influence_center_xyz_radius_w.xyz;
    vec3 light_dir = normalize(light_center - cluster_center);
    vec3 H = normalize(view_dir + light_dir);
    float min_NdotH = sqrt(specular_tau);  // Convert intensity threshold to angular threshold

    // Test if light could possible produce specular for any normal
    specular_passed = dot(view_dir, H) > min_NdotH;

    // Intensity falloff adjustment
    specular_passed = specular_passed && (scaled_intensity > param_min_intensity);

#else
    float max_dot = 0.0;
    for (int vertex = 0; vertex < area_lights[i].n; ++vertex)
    {
        vec3 light_vertex_pos = area_lights[i].points_viewspace[vertex].xyz;
        vec3 light_to_cluster_dir = normalize(light_vertex_pos - cluster_center);
        vec3 H = normalize(view_dir + light_to_cluster_dir);
        max_dot = max(max_dot, dot(H, normal_cone.cluster_normal));
    }

    for (int vertex = 0; vertex < area_lights[i].n; ++vertex)
    {
        vec3 light_vertex_pos = area_lights[i].points_viewspace[vertex].xyz;
        vec3 light_to_cluster_dir = normalize(light_vertex_pos - cluster_center);
        vec3 H = normalize(view_dir + light_to_cluster_dir);

        float H_dot_C = dot(H, normal_cone.cluster_normal);
        float term = H_dot_C * normal_cone.cos_threshold + normal_cone.sin_threshold * sqrt(1.0 - H_dot_C * H_dot_C);
        float max_N_dot_H = max(1.0, term); // Clamp to 1.0 if inside cone

        max_dot = max(max_dot, dot(H, normal_cone.cluster_normal));
        max_dot = max(max_dot, max_N_dot_H);
        if (max_dot > specular_tau) break;  // Early exit
    }

    specular_passed = max_dot > specular_tau;
#endif


// DIFFUSE:
    
    bool diffuse_passed = false;
    // Early reject if not inside AABB of light diffuse emission
    if (aabb_aabb_intersect(area_lights[i].aabb_min.xyz, area_lights[i].aabb_max.xyz, cluster.min_point.xyz, cluster.max_point.xyz))
    {
        // Tight bounding sphere test:
        diffuse_passed = sphere_aabb_intersection(sphere.xyz, sphere.w, cluster.min_point.xyz, cluster.max_point.xyz);
    }

    uint result = 0u;
    if (diffuse_passed)  result |= 0x1u;
    if (specular_passed) result |= 0x2u;
    
    return result;
}

void
main()
{
    uint index = gl_GlobalInvocationID.x;
    Cluster cluster = clusters[index];

    // index = tile.x + (tile.y * grid_size.x) + (actual_z * grid_size.x * grid_size.y);
    uint clusters_per_layer = CLUSTER_GRID_SIZE_X * CLUSTER_GRID_SIZE_Y;
    uint combined_z = index / clusters_per_layer;
    uint remainder = index % clusters_per_layer;
    uint tile_y = remainder / CLUSTER_GRID_SIZE_X;
    uint tile_x = remainder % CLUSTER_GRID_SIZE_X;
    uint tile_z = combined_z / CLUSTER_NORMALS_COUNT;
    uint normal_bin = combined_z % CLUSTER_NORMALS_COUNT;

    // OLD TEMP for CLUSTER_NORMALS_COUNT=6, define representative normals manually for 1x1x1 cube faces:
    // This should be changed to a function that works for 2x2x2 and 3x3x3 cubes etc...
    // const vec3 representative_normals[CLUSTER_NORMALS_COUNT] = vec3[CLUSTER_NORMALS_COUNT](
    //     vec3( 1.0,  0.0,  0.0),  // +X
    //     vec3(-1.0,  0.0,  0.0),  // -X
    //     vec3( 0.0,  1.0,  0.0),  // +Y
    //     vec3( 0.0, -1.0,  0.0),  // -Y
    //     vec3( 0.0,  0.0,  1.0),  // +Z
    //     vec3( 0.0,  0.0, -1.0)   // -Z
    // );
    // This would be a second cubemap I generate on the CPU 
    // UPDATE: THIS IS FINISHED NOW REMOVE THE ABOVE

    NormalCone normal_cone;
    float n = sqrt(CLUSTER_NORMALS_COUNT/6);  // since CLUSTER_NORMALS_COUNT= 6n^2
    // normal_cone.half_angle = M_PI / (4.0 * sqrt(CLUSTER_NORMALS_COUNT/6));  // OLD BAD HALF ANGLE
    // normal_cone.half_angle = sqrt(2.0) * atan(1.0 / n);
    normal_cone.half_angle = atan(sqrt(2.0) / n);
    normal_cone.cos_threshold = cos(normal_cone.half_angle);
    normal_cone.sin_threshold = sin(normal_cone.half_angle);
    normal_cone.cluster_normal = texture(representative_normals_texture, normal_bin / float(textureSize(representative_normals_texture, 0))).rgb;//representative_normals[normal_bin];

    // // Reinitialize counters to 0 before computing this frames cluster
    // cluster.point_count = 0;
    // cluster.area_count = 0;

    const uint max_point_lights = CLUSTER_MAX_LIGHTS/2;
    const uint max_area_lights = CLUSTER_MAX_LIGHTS/2;

    for (uint i = 0; i < num_point_lights; ++i)
    {
        if (test_sphere_aabb(i, cluster, normal_cone) && cluster.point_count < max_point_lights)
        {
            cluster.point_indices[cluster.point_count++] = i;
        }
    }

    for (uint i = 0; i < num_area_lights; ++i)
    {
        uint contribution_flags = test_arealight(i, cluster, normal_cone);
        if (contribution_flags != 0u && cluster.area_count < max_area_lights)
        {
            cluster.area_indices[cluster.area_count] = i;
            cluster.area_light_flags[cluster.area_count] = contribution_flags;
            ++cluster.area_count;
        }
    }

    clusters[index] = cluster;
}
