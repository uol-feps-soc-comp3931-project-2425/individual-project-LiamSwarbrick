
Heitz 2017 [Eric Heitz. Geometric Derivation of the Irradiance of Polygonal Lights. [Research Report] Unity
Technologies. 2017. ffhal-01458129f]

The closed form expression for the irradiance of an n polygon onto a hemisphere is
I(v_1, ..., v_n) = \frac{1}{2\pi} \sum_{i=1}^n acos(p_i \cdot p_j)\left( \frac{p_i \times p_j}{||p_i \times p_j||} \cdot [0,0,1]^T \right)

Heitz (2017) shows a helpful geometric interpretation of the irradiance as the area of the unit disk as a projection down from the unit hemispherical enclosing it.
I(v1,v2,v3,v4) = sum of disk sectors = I_{12} + I_{23} + I_{34} + I_{41}.


Clipping polygon to hemisphere: Sutherland-Hodgeman implementation over halfspace z>=0.

Derivation for my choice of MAX_NGON:
=======================================
Basing maximum area light polycount based on MAX_NGON, the postclipping size:
- Looking at the algorithm we can see the worst case is when the polygon's vertices alternate between
  inside hemisphere and outside hemisphere which will add an extra vertex for every other edge which
  means that the worst case is out_n = in_n + in_n/2 = floor(3 in_n / 2).
  So if we want to handle a star shaped polygon (10 input vertices then MAX_NGON must be >= 15)
    if (current_point_inside_hemisphere)
    {
        if (!prev_point_inside_hemisphere)
        {
            outpoints[out_n++] = intersecting_point;
        }
        outpoints[out_n++] = current_point;
    }
    else if (prev_point_inside_hemisphere)
    {
        outpoints[out_n++] = intersecting_point;
    }
Result in latex: \text{MAX\_NGON} \ge \lfloor\frac{3\,in\_n}{2}\rfloor.
// A decagon can produce a star shaped area light similar to the figure in the Heitz paper


Displaying the actual polygons being used as lights:
the problem is, the ltc polygons are defined as (v1, v2, ..., vn) with
edges (v1,v2), (v2,v3), ..., (v{n-1}, vn) and (vn, v1),
If i just submit those vertices directly with GL_TRIANGLE_FAN it won't work,
since that is only good for rendering convex polygons.
The LTC code is fine with that since it works for concave polygons but the rendering code must
first triangulate the mesh. I use a simple method that works for mildy concave polygons like star shapes...



area_light_shape_data.h
// Defined anti-clockwise, these are n-gons, not triangle meshes
// This makes it problematic to actually render the light sources when they are concave
// since that would require triangulation, so instead I'm just using convex polygons,
// except the star, where I've hardprogrammed the triangle mesh to avoid having to implement
// an ear-clipping algorithm for concave ngon triangulation.


Could mention how I didn't test different cluster shapes e.g. only voxel not froxel

Couldn't use area_lights.length() in for loop because when the ssbo is empty, it returns a big random number and slows the program.
So instead use uniforms for num_area_lights