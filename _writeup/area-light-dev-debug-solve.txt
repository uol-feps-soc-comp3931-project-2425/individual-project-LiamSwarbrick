One example of how thorough you must be in GPU programming is this...
my area light points didn't seem to be in the right place, and were also attached to the camera
even though they were defined in worldspace on the CPU before being uploaded in viewspace.
Clearly not right, but to me all the code uploading the positions looked correct...
Eventually I visuallised the points in the shader and noticed changing the 4th component of the position vector effected one of the points position,
this indicates an alignment issue when uploading to the GPU....
I finally remembered I structured my area light in glsl like so...
struct AreaLight
{
    vec4 color_rgb_intensity_a;
    int n;
    vec4 points_viewspace[MAX_UNCLIPPED_NGON];  // 4th component unused, vec3[] would be packed the same way but vec3 is implemented wrong on some drivers
};

layout (std430, binding = 2) restrict buffer area_light_ssbo
{
    AreaLight area_lights[];
};

Here you can see I'm using a std430 OpenGL shader storage block (SSBO) to hold this struct...

On the CPU side I uploaded this struct to the SSBO manually using memory mapping...
    // Update area lights buffer
    f32* mapped_arealight_ssbo = (float*)glMapNamedBuffer(scene->area_light_ssbo, GL_WRITE_ONLY);
    ...

    float* mapped_arealight = &mapped_arealight_ssbo[area_id * sizeof(AreaLight) / sizeof(f32)];

    // Set mapped color and intensity
    mapped_arealight[0] = area_light->color_rgb_intensity_a[0];
    mapped_arealight[1] = area_light->color_rgb_intensity_a[1];
    mapped_arealight[2] = area_light->color_rgb_intensity_a[2];
    mapped_arealight[3] = area_light->color_rgb_intensity_a[3];

    ((int*)mapped_arealight)[4] = area_light->n;

    // Set mapped area light points
    for (int vertex = 0; vertex < MAX_UNCLIPPED_NGON; ++vertex)
    {
        mapped_arealight[5 + vertex*4 + 0] = points_viewspace[vertex][0];
        mapped_arealight[5 + vertex*4 + 1] = points_viewspace[vertex][1];
        mapped_arealight[5 + vertex*4 + 2] = points_viewspace[vertex][2];
        mapped_arealight[5 + vertex*4 + 3] = points_viewspace[vertex][3];
    }

    ...
    glUnmapNamedBuffer(scene->area_light_ssbo);

Here's where the problem lies...
My glsl area light struct is aligned according to std430 alignment rules.
vec4 is aligned to 16 byte boundaries, therefore there is 3 floats of packing between 'int n' and the next vec4.
But in my CPU side code I uploaded it as if it was tightly packed.

So the actual memory layout of the glsl struct was like so...
struct AreaLight
{
    vec4 color_rgb_intensity_a;
    int n;
    float _packing0;
    float _packing1;
    float _packing2;
    vec4 points_viewspace[MAX_UNCLIPPED_NGON];  // 4th component unused, vec3[] would be packed the same way but vec3 is implemented wrong on some drivers
};

Accounting for this on the CPU side, I finally get my first area light results with the simple clamped cosine.
It made sense why the points were attached to the camera as well, since the 4th component of the vector was aligned wrong too,
and the 4th component of a position vector in 3d space must be 1.0 in order to accumulate the translation component of the view matrix, but were uploaded as 0.0.

My clipping algorithm was still not working properly... The white pixels indicate the shader has a runtime error in that case...
probably an out of bounds access.

